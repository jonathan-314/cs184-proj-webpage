<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Meshedit</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2023</h1>
<h1 align="middle">Project 2: Meshedit</h1>
<h2 align="middle">Jonathan Guo, Wentinn Liao, cs184-jgwl</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>TODO In this project, we implemented </p>



<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier Curves with 1D de Casteljau Subdivision</h3>

<p>The Casteljau algorithm for Bezier curves recursively computes a linear interpolation of the control points. For each iteration, we iterated through the given control points and computed (1-t)p[i] + tp[i+1], which we then returned. If this function was called recursively until there was one point left, that point would be on the bezier curve. The figures below show how each iteration is computed from the previous iteration, using t = 0.5 (so it takes the midpoint of the previous control points)</p>

<div align="middle">
	<table style="width=100%">
		<tr>
			<td>
		    <img src="images/Task 1/bzc0.png" align="middle" width="400px"/>
		    <figcaption align="middle">Iteration 0 <em>bzc/curve6.bzc</em>.</figcaption></td>
		    <td>
		    <img src="images/Task 1/bzc1.png" align="middle" width="400px"/>
		    <figcaption align="middle">Iteration 1 <em>bzc/curve6.bzc</em>.</figcaption></td>
		</tr>
		<tr>
			<td>
		    <img src="images/Task 1/bzc2.png" align="middle" width="400px"/>
		    <figcaption align="middle">Iteration 3 <em>bzc/curve6.bzc</em>.</figcaption></td>
		    <td>
		    <img src="images/Task 1/bzc3.png" align="middle" width="400px"/>
		    <figcaption align="middle">Iteration 3 <em>bzc/curve6.bzc</em>.</figcaption></td>
		</tr>
		<tr>
			<td>
		    <img src="images/Task 1/bzc4.png" align="middle" width="400px"/>
		    <figcaption align="middle">Iteration 4 <em>bzc/curve6.bzc</em>.</figcaption></td>
		    <td>
		    <img src="images/Task 1/bzc5.png" align="middle" width="400px"/>
		    <figcaption align="middle">Iteration 5 <em>bzc/curve6.bzc</em>.</figcaption></td>
		</tr>
	</table>
</div>
<p>The image below shows the completed Bezier curve, computed by iterating over many t values between 0 and 1 using the above method. </p>
<div align="middle">
    <img src="images/Task 1/bzc6.png" align="middle" width="400px"/>
    <figcaption align="middle"><em>bzc/curve6.bzc</em>.</figcaption>
</div>
<p>Finally, the image below shows the Bezier curve after some of the original control points were modified and with a different t value. </p>
<div align="middle">
    <img src="images/Task 1/bzc7.png" align="middle" width="400px"/>
    <figcaption align="middle"><em>bzc/curve6.bzc</em>.</figcaption>
</div>

<h3 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau</h3>

<p>The Casteljau algorithm for Bezier surfaces simply calls the 1D version multiple times. For the first dimension, 1D Casteljau interpolation is called on each row for parameter <strong>u</strong>. For an <strong>n x n</strong> grid of control points, this produces a vector of <strong>n</strong> intermediate control points. 1D Casteljau interpolation is called again on these intermediate control points with parameter <strong>v</strong> to obtain the final desired point.</p>

<div align="middle">
    <img src="images/Task 2 Teapot.png" align="middle" width="400px"/>
    <figcaption align="middle"><em>bez/teapot.bez</em>.</figcaption>
</div>

<div align="middle">
    <table style="width=100%">
        <tr>
            <td>
                <img src="images/Task 2 Rate 1.png" align="middle" width="300px"/>
                <figcaption align="middle">Supersampling rate 1 <em>basic/test4.svg</em>.</figcaption>
            </td>
            <td>
                <img src="images/Task 2 Rate 4.png" align="middle" width="300px"/>
                <figcaption align="middle">Supersampling rate 4 <em>basic/test4.svg</em>.</figcaption>
            </td>
            <td>
                <img src="images/Task 2 Rate 16.png" align="middle" width="300px"/>
                <figcaption align="middle">Supersampling rate 16 <em>basic/test4.svg</em>.</figcaption>
            </td>
        </tr>
    </table>
</div>

<p>We can see that there is a great disconnection on the left when the sampling rate is 1, while 4 is blurred and 16 is more finely blurred. This small scale effect is due to the fact that not all supersamples of a pixel lie inside the triangle and the color assigned to the pixel now depends on the fraction of supersamples that lie in the triangle. On a large scale, this visually reduces aliasing artifacts. We do not see the blur from far away because at a single point, our retina sees an average of light reflecting from a small local region so a uniform blurred color achieves the same effect as would many smaller pixels without supersampling.</p>



<h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>

<h3 align="middle">Part 3: Area-Weighted Vertex Normals</h3>

<div align="middle">
    <img src="images/Task 3 Robot Wave.png" align="middle" width="400px"/>
    <figcaption align="middle">Robot Waving. </figcaption>
</div>

<p>Here we tried making our robot wave. This was achieved by rotating the robot's head as well as the robot's arm by various degrees. However, with the rotation of the head/arm, we also had to translate those back to their original position as the rotation took them out of position.


<h3 align="middle">Part 4: Edge Flip</h3>

<div align="middle">
    <img src="images/Barycentric Interpolation Example.png" align="middle" width="400px"/>
    <figcaption align="middle">Barycentric interpolation of colors.</figcaption>
</div>

<p>Barycentric coordinates express any point as the weighted average of the vertices of a polygon (or polyhedron in multiple dimensions) which allows two dimensional interpolation with three points. Furthermore, the interpolation is also linear, because the line connecting any two points is colored with a linear gradient. This is useful for both color and texture interpolation of the triangle interior.</p>

<div align="middle">
    <img src="images/Task 4.png" align="middle" width="400px"/>
    <figcaption align="middle">Barycentric interpolation <em>basic/test7.svg</em>.</figcaption>
</div>


<h3 align="middle">Part 5: Edge Split</h3>

<p>Pixel sampling is a way of obtaining or approximating the desired texture for intermediate pixels. Both nearest and bilinear start with barycentric interpolation of the texel coordinates of the vertices to obtain the appropriate texel coordinates of the desired pixel. Nearest pixel sampling rounds the texel coordinates to the nearest integer and matches the texture at those integer coordinates. In contrast, bilinear pixel sampling takes the texture values at the vertices of the unit square containing the pixel coordinates and makes a linear interpolation in the u and v directions (texel coordinates). This allows a smoother gradient for "large" pixels, i.e. pixels containing many texel lattices.</p>

<div align="middle">
    <table style="width=100%">
        <tr>
            <td>
                <img src="images/Task 5 Nearest Rate 1.png" align="middle" width="400px"/>
                <figcaption align="middle">Nearest pixel sampling rate 1 <em>texmap/test5.svg</em>.</figcaption>
            </td>
            <td>
                <img src="images/Task 5 Nearest Rate 16.png" align="middle" width="400px"/>
                <figcaption align="middle">Nearest pixel sampling rate 16 <em>texmap/test5.svg</em>.</figcaption>
            </td>
        </tr>
        <br>
        <tr>
            <td>
                <img src="images/Task 5 Bilinear Rate 1.png" align="middle" width="400px"/>
                <figcaption align="middle">Bilinear pixel sampling rate 1 <em>texmap/test5.svg</em>.</figcaption>
            </td>
            <td>
                <img src="images/Task 5 Bilinear Rate 16.png" align="middle" width="400px"/>
                <figcaption align="middle">Bilinear pixel sampling rate 16 <em>texmap/test5.svg</em>.</figcaption>
            </td>
        </tr>
    </table>
</div>

<p>As seen above, bilinear texture sampling already nearly approximates rate 16 antialiasing of nearest pixel. Bilinear interpolation visually outperforms nearest neighbor when few texture pixels correspond to many pixels, i.e. when texels are stretched across an obtuse triangle. Nearest pixel will show a significant dropoff between texture lattice points, while bilinear interpolation will produce a smooth linear gradient.</p>


<h3 align="middle">Part 6: Loop Subdivision for Mesh Upsampling</h3>

<p>Level sampling allows us to compute pixel sampling faster and allow for more antialiasing. Instead of going pixel by pixel, level sampling may in some cases jump by many pixels at once (by taking the average which has been precomputed). This allows us to render the images faster. Increasing the number of samples per pixel decreases speed, increases memory usage, and increases antialiasing power since we sample a lot more. Level sampling, on the other hand, is the opposite: as the level number increases, the image becomes blurrier, so it is faster, uses less memory, but also has decreased antialising power. Finally, pixel sampling nearest is slightly faster than bilinear but also is susceptible to aliases. </p>

<div align="middle">
    <table style="width=100%">
        <tr>
            <td>
                <img src="images/Task 6 L0PN.png" align="middle" width="400px"/>
                <figcaption align="middle">Level 0, Nearest Pixel <em>./test6.svg</em>.</figcaption>
            </td>
            <td>
                <img src="images/Task 6 L0PB.png" align="middle" width="400px"/>
                <figcaption align="middle">Level 0, Bilinear Pixel <em>./test6.svg</em>.</figcaption>
            </td>
        </tr>
        <br>
        <tr>
            <td>
                <img src="images/Task 6 LBPN.png" align="middle" width="400px"/>
                <figcaption align="middle">Bilinear Level, Nearest Pixel <em>./test6.svg</em>.</figcaption>
            </td>
            <td>
                <img src="images/Task 6 LBPB.png" align="middle" width="400px"/>
                <figcaption align="middle">Bilinear Level, Bilinear Pixel <em>./test6.svg</em>.</figcaption>
            </td>
        </tr>
    </table>
</div>

<p>Above show the effects of the various pixel and level sampling methods. As seen above, bilinear pixel causes the image to become more blurred, similar to bilinear levels. However, the bilinear level has a way larger effect than the bilinear pixel. This is because the bilinear pixel is only affected by its neighboring pixels, while the bilinear level could cause each pixel to be affected by pixels dozens of pixels away. </p>

<h2 align="middle">Section III: Art Competition</h2>
<p>If you are not participating in the optional art competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Draw something interesting!</h3>


</body>
</html>
