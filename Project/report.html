<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_mqnvcge7nm4b-1{list-style-type:none}ul.lst-kix_mqnvcge7nm4b-0{list-style-type:none}ul.lst-kix_2whi0pyhiphv-5{list-style-type:none}ul.lst-kix_2whi0pyhiphv-6{list-style-type:none}ul.lst-kix_2whi0pyhiphv-3{list-style-type:none}ul.lst-kix_2whi0pyhiphv-4{list-style-type:none}ul.lst-kix_2whi0pyhiphv-1{list-style-type:none}ul.lst-kix_2whi0pyhiphv-2{list-style-type:none}ul.lst-kix_2whi0pyhiphv-0{list-style-type:none}.lst-kix_2whi0pyhiphv-5>li:before{content:"\0025a0  "}.lst-kix_2whi0pyhiphv-4>li:before{content:"\0025cb  "}ul.lst-kix_2whi0pyhiphv-7{list-style-type:none}ul.lst-kix_2whi0pyhiphv-8{list-style-type:none}ul.lst-kix_mqnvcge7nm4b-8{list-style-type:none}.lst-kix_2whi0pyhiphv-3>li:before{content:"\0025cf  "}ul.lst-kix_mqnvcge7nm4b-7{list-style-type:none}.lst-kix_2whi0pyhiphv-1>li:before{content:"\0025cb  "}.lst-kix_mqnvcge7nm4b-1>li:before{content:"\0025cb  "}ul.lst-kix_mqnvcge7nm4b-6{list-style-type:none}ul.lst-kix_mqnvcge7nm4b-5{list-style-type:none}ul.lst-kix_mqnvcge7nm4b-4{list-style-type:none}.lst-kix_mqnvcge7nm4b-2>li:before{content:"\0025a0  "}ul.lst-kix_mqnvcge7nm4b-3{list-style-type:none}.lst-kix_2whi0pyhiphv-2>li:before{content:"\0025a0  "}ul.lst-kix_mqnvcge7nm4b-2{list-style-type:none}.lst-kix_mqnvcge7nm4b-3>li:before{content:"\0025cf  "}.lst-kix_mqnvcge7nm4b-4>li:before{content:"\0025cb  "}.lst-kix_2whi0pyhiphv-0>li:before{content:"\0025cf  "}.lst-kix_mqnvcge7nm4b-0>li:before{content:"\0025cf  "}.lst-kix_mqnvcge7nm4b-7>li:before{content:"\0025cb  "}.lst-kix_mqnvcge7nm4b-5>li:before{content:"\0025a0  "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_mqnvcge7nm4b-6>li:before{content:"\0025cf  "}.lst-kix_2whi0pyhiphv-6>li:before{content:"\0025cf  "}.lst-kix_2whi0pyhiphv-7>li:before{content:"\0025cb  "}.lst-kix_2whi0pyhiphv-8>li:before{content:"\0025a0  "}.lst-kix_mqnvcge7nm4b-8>li:before{content:"\0025a0  "}ol{margin:0;padding:0}table td,table th{padding:0}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Times New Roman";font-style:italic}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Times New Roman";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:19pt;font-family:"Times New Roman";font-style:italic}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c8{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c16{color:#000000;text-decoration:none;vertical-align:baseline;font-size:21pt;font-style:normal}.c14{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c17{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#0000ee;text-decoration:underline}.c18{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c7{font-size:13pt;font-family:"Times New Roman";font-weight:400}.c3{vertical-align:super;font-family:"Times New Roman";font-weight:400}.c2{font-weight:400;font-family:"Courier New"}.c13{font-weight:400;font-family:"Times New Roman"}.c4{margin-left:36pt;padding-left:0pt}.c11{color:inherit;text-decoration:inherit}.c15{padding:0;margin:0}.c19{font-size:13pt}.c20{font-style:italic}.c1{height:11pt}.c9{page-break-after:avoid}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Times New Roman"}p{margin:0;color:#000000;font-size:11pt;font-family:"Times New Roman"}h1{padding-top:0pt;color:#000000;font-size:19pt;padding-bottom:0pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:center}h2{padding-top:0pt;color:#000000;font-size:15pt;padding-bottom:0pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c18 doc-content"><p class="c8"><span class="c13 c16">CS184 Computer Graphics and Imaging - Spring 2023</span></p><p class="c8"><span class="c6">Final Project - Particle-Based Fluid Simulation</span></p><p class="c8"><span class="c7">Jonathan Guo, Andrew Huang, Wentinn Liao, </span><span class="c19">Alison Siebert</span><hr></p><p class="c8 c1"><span class="c12"></span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 444.00px; height: 378.26px;"><img alt="" src="images/image30.png" style="width: 483.52px; height: 378.26px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c1"><span class="c12"></span></p><p class="c8"><span class="c6">Abstract</span></p><p class="c8 c1"><span class="c12"></span></p><p class="c0"><span class="c13">Our final project attempts to simulate uniform fluid interactions in a solid environment using a particle based model</span><span>, and improve the dynamic characteristics of movement while still preserving stability. This improved stability comes from modifying the incompressibility updates to improve continuity across the simulation and therefore allowing us to increase vorticity and decrease viscosity without blowing up, and maintaining surface cohesion. </span><span class="c13">We combine ideas from multiple papers as well as bring many of our own ideas to improve the efficiency and quality of our simulations. As opposed to modeling the standard forces shown in the Navier-Stokes equation, our model implements forward simulation with external forces, collision, incompressibility, vorticity, and viscosity.</span><span>&nbsp;</span><span class="c13">Computation of neighbor particles uses a static array based on the fluid parameters and the initialization parameters of the fluid. Each simulation step is followed by mesh generation using the cube marching algorithm, facilitated as well by the array used for neighborhood computation. </span><span>Our model is flexible enough to model a variety of different fluids with different densities, viscosities, etc.</span></p><p class="c0 c1"><span class="c5"></span></p><h1 class="c8 c9" id="h.jdfrblclbce5"><span class="c6">Technical Approach</span></h1><p class="c0 c1"><span class="c12"></span></p><h2 class="c0 c9" id="h.4st8lnxmgdcp"><span class="c10">Code Structure</span></h2><p class="c0"><span class="c13">Our code is based on the structure used for Project 4, however with many modifications. We similarly define a </span><span class="c2">Fluid</span><span class="c13">&nbsp;class that contains methods lending to the computation of the forward pass and rendering. The fluid itself is parameterized using the struct </span><span class="c2">FluidParameters</span><span class="c13">&nbsp;that defines the static properties of the fluid, such as density, molar mass, average particle spacing, and RMS velocity. Our particles are considered as point masses for the sake of forward simulation, although the proportional particle radius is kept in mind as an approximate cell size for the cube marching algorithm. </span><span>Once the positions of the particles have been determined, we utilize the cube marching algorithm to construct a triangular mesh of the surface of the fluid. This mesh is then passed into the Project 4 shaders for rendering. </span></p><p class="c0 c1"><span class="c5"></span></p><h2 class="c0 c9" id="h.wfhz4cnclwj8"><span class="c10">Mathematical Definitions and Constants</span></h2><p class="c0"><span class="c13">It is </span><span>obviously</span><span class="c5">&nbsp;impractical to simulate fluids to the number of particles that would exist in real life. However, we did our best to scale the necessary constants to produce the best accuracy possible. A core function that is essential to the entire project is the kernel function, which models a particle&rsquo;s degree of influence on neighboring particles. It is used to approximate local density, gradient and curl for incompressibility and vorticity updates, and viscous flow. The kernel function we used is defined as</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 285.33px; height: 62.67px;"><img alt="" src="images/image31.gif" style="width: 285.33px; height: 62.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span>denoted </span><img src="images/image1.png"><span>&nbsp;for short, w</span><span class="c13">here </span><img src="images/image2.png"><span class="c13">&nbsp;and </span><img src="images/image3.png"><span class="c13">&nbsp;are the positions of the particles, </span><img src="images/image4.png"><span class="c13">&nbsp;is a constant known as the </span><span class="c13 c20">smoothing radius</span><span class="c13">, and </span><img src="images/image5.png"><span class="c13">&nbsp;is the normalized distanc</span><span>e between the two particles, calculated by dividing the Euclidean distance by the smoothing radius. It is important for future math to note that </span><img src="images/image6.png"><span>. Thus, particles beyond twice the smoothing radius are approximated to have no influence on a particle, and therefore, the size of the cells we use for neighbor computations is </span><img src="images/image7.png"><span class="c5">. The initial method of computing the appropriate smoothing radius was to simply scale up the average distance between molecules. This would be calculated as</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 434.67px; height: 36.00px;"><img alt="" src="images/image32.png" style="width: 434.67px; height: 36.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span>Where </span><img src="images/image8.png"><span>&nbsp;is the molar mass, </span><img src="images/image9.png"><span>&nbsp;is Avogadro&rsquo;s number, </span><img src="images/image10.png"><span>&nbsp;and </span><img src="images/image11.png"><span>&nbsp;are the number of particles that would exist in reality and would be used in the simulation respectively, and </span><img src="images/image12.png"><span class="c5">&nbsp;is the average spacing between particles. The local density estimator is calculated as</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 109.33px; height: 36.00px;"><img alt="" src="images/image34.png" style="width: 109.33px; height: 36.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span>where </span><img src="images/image13.png"><span>&nbsp;denotes the neighborhood of particle </span><img src="images/image14.png"><span>. However, this empirically violates the key intuition that if we randomly sample particles from the initialization volume, then the average density should equal the true density observed in reality. To fix this required scaling up our initial computation of the smoothing radius. It was experimentally determined that this should be done by a factor of </span><img src="images/image15.png"><span class="c5">&nbsp;which also produced better results in terms of stability.</span></p><p class="c0 c1"><span class="c5"></span></p><p class="c0"><span class="c10">Incompressibility and Tensile Instability</span></p><p class="c0"><span class="c5">The original paper modeled incompressibility as the constraint</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 76.00px; height: 29.33px;"><img alt="" src="images/image26.png" style="width: 76.00px; height: 29.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span>where </span><img src="images/image16.png"><span>&nbsp;is the natural observed density of the fluid. It took a Newton&rsquo;s descent approach, taking the gradient of a single constraint </span><img src="images/image17.png"><span class="c5">&nbsp;with respect to the position of all its neighbors to compute a constant</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 160.00px; height: 37.33px;"><img alt="" src="images/image28.png" style="width: 160.00px; height: 37.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c5">&nbsp;by which to step. It then made this step by computing</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 296.00px; height: 41.33px;"><img alt="" src="images/image39.png" style="width: 296.00px; height: 41.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c5">Our method however deviated from this in many ways. First was the observation that the step taken by Newton&rsquo;s descent on the sum of constraints is not necessarily the sum of the steps that Newton&rsquo;s descent would take on the individual constraints. Therefore, rather than taking the gradient of a single constraint with respect to multiple points and superimposing, we instead took the gradient of superimposed constraints with respect to a single point. A premature form of this looked like</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 254.67px; height: 52.00px;"><img alt="" src="images/image35.png" style="width: 254.67px; height: 52.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span>which also preserves integrity of units. The second observation made is that particles should care less about adjusting to satisfy the constraints of farther particles than nearer ones, including itself. In the center, this is generally fine, but near the outside, this produces motivation to move even further out. Therefore, we modify the loss function to be the weighted sum of the constraints, where the weights are proportional to the kernel values with respect to particle </span><img src="images/image14.png"><span class="c5">.</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 384.00px; height: 58.67px;"><img alt="" src="images/image36.png" style="width: 384.00px; height: 58.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c5">The third modification we made is based on the observation that incompressibility means that fluids cannot be compressed beyond a certain density which means that particles compressed beyond natural density should be motivated to move further apart. However, there is no reason that particles that occur more sparsely should be motivated to become even sparser. The original constraint indiscriminately separates particles which causes those on the outer surface to go unstable. Therefore, we make a modification to the constraint function to then become</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 256.00px; height: 26.67px;"><img alt="" src="images/image38.png" style="width: 256.00px; height: 26.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c5">which only penalizes the particle if a neighboring one has a higher local density than should be. In practice, this means for both the numerator and denominator, we only sum the loss term or its gradient if the local density exceeds the natural density of the fluid. All these changes improved the stability of our simulations, however still resulted in particles flying out more than they should. The final modification notes that a Newton&rsquo;s descent is geared towards a fast convergence to the local optimum. However, if the local optimum is reasonably far from the current state, then a fast convergence clashes with the intuition of continuity that should be present in a simulation. Therefore, we found it more natural as well as efficient to instead use gradient descent. This reduced the update to</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 424.00px; height: 53.33px;"><img alt="" src="images/image29.png" style="width: 424.00px; height: 53.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span>where </span><img src="images/image18.png"><span>&nbsp;is a step size chosen to be </span><img src="images/image19.png"><span class="c5">&nbsp;based on empirical results. This is added to the paper&rsquo;s proposed update for tensile instability</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 489.33px; height: 45.33px;"><img alt="" src="images/image33.png" style="width: 489.33px; height: 45.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c5">to which we made no modifications.</span></p><p class="c0 c1"><span class="c5"></span></p><p class="c0"><span>One final thing to note is the distinction between collision and constraint with respect to the wall surfaces. When particles moving quickly collide with a wall, they tend to bounce back at some speed and direction roughly proportional to the incoming velocity. We found it, however, more stable to differentiate between collision object updates during movement and during incompressibility adjustment. We therefore added an additional functionality </span><span class="c2">constrain</span><span>&nbsp;vs </span><span class="c2">collide</span><span>, in which </span><span class="c2">constrain</span><span class="c5">&nbsp;merely modifies the particle position to be back within bounds without modifying any other properties.</span></p><p class="c0 c1"><span class="c5"></span></p><p class="c0"><span class="c10">Vorticity</span></p><p class="c0"><span class="c5">Our implementation of vorticity makes a slight modification to account for the ratio of the volume to the number of particles. Because debugging is a large part of the project, implementing vorticity along with other terms as stated in the original paper yielded a wide range of significantly different results across different numbers of particles, some which became unstable and others which didn&rsquo;t. This required us to make our equations robust to this ratio. Thus, the curl velocity is modified to be</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 324.00px; height: 41.33px;"><img alt="" src="images/image37.png" style="width: 324.00px; height: 41.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c5">The total acceleration due to vorticity is then defined as</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 362.67px; height: 30.67px;"><img alt="" src="images/image25.png" style="width: 362.67px; height: 30.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span>In our case, we chose </span><img src="images/image20.png"><span>&nbsp;to be </span><img src="images/image21.png"><span class="c5">.</span></p><p class="c0 c1"><span class="c5"></span></p><p class="c0"><span class="c10">Viscosity</span></p><p class="c0"><span class="c5">The viscosity term was the easiest to implement, following the original paper exactly. The viscosity update is given by</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 205.33px; height: 17.33px;"><img alt="" src="images/image24.png" style="width: 205.33px; height: 17.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span>where </span><img src="images/image22.png"><span class="c5">. However, this term can be varied to produce a large range of effects. A large viscosity produces a smoother surface and better surface cohesion while lower viscosity allows us to see individual droplets.</span></p><p class="c0 c1"><span class="c5"></span></p><p class="c0"><span class="c10">Adaptive Sampling</span></p><p class="c0"><span>If there is not very much movement, it is not very essential to sample movement as frequency as often. On the contrary, at an instance where there is much movement, it is more essential to have more samples per second in order to reduce error. As a result, we briefly attempted adaptive sampling. In our </span><span class="c2">simulate</span><span>&nbsp;function, we include a time step duration which was determined by </span><span class="c2">clothSimulator</span><span class="c5">&nbsp;depending on the velocities and forces on the particles. This would allow us to increase the frame-per-second in the more important parts. Moreover, we could use linear interpolation during the less-sampled periods to get accurate approximations for where particles are in these cases.</span></p><p class="c0"><span>However, one problem that we came across is that given our long rendering times and the large discrepancy between the most and least active frames, it would be almost impossible to get satisfactorily-looking linear interpolation in a reasonable amount of time. </span></p><p class="c0 c1"><span class="c5"></span></p><p class="c0"><span class="c10">Spatial Hashing and Basic Mesh Structure Properties</span></p><p class="c0"><span>Similar to Project 4, we utilize spatial hashing to increase the performance of our code. However, unlike Project 4, our liquid is already confined within a container. This means that we can utilize a predefined static 3-dimensional array as our hash table and simply move particles from one index to another when their positions move. (In reality, this is actually a 4-dimensional array, as each index in the original 3-dimensional array is an array of particles). </span></p><p class="c0 c1"><span class="c5"></span></p><h2 class="c0 c9" id="h.8rzdxikfn16b"><span class="c10">Cube Marching Algorithm</span></h2><p class="c0"><span class="c13">To render the surface of the fluid, we use the cube marching algorithm. </span><span>Initially</span><span class="c13">, we divide the fluid up into small cubes. We already have a grid used for </span><span>spatial</span><span class="c13">&nbsp;hashing, but we subdivide each cell further. Within each cube, we compute a density value based upon nearby particles. The density function we chose </span><span>was proportional to one over the distance from the particle cubed. </span><span class="c13">Then, our surface is a 3-dimensional contour diagram based on some </span><span>predetermined</span><span class="c13">&nbsp;threshold value. Within each cube that the surface passes through, there are some corners that have density values below the threshold value and some that are above the threshold value. Given these values, we use a union find algorithm to group neighboring vertices whose value is below the threshold together, and then </span><span>linearly </span><span class="c13">interpolate the </span><span>outgoing</span><span class="c5">&nbsp;edges (edges that connect to vertices whose value is higher than the threshold) to compute the position of a corner of the mesh. Finally, we construct a triangular mesh from these positions. </span></p><p class="c0 c1"><span class="c5"></span></p><p class="c0"><span class="c13">However, the papers we looked at utilized a different approach. Because each cube has 8 corners, there are only 2</span><span class="c3">8</span><span class="c13">&nbsp;= 256 possible configurations of vertices (above/below the threshold, if we view that as a boolean value). Furthermore, a lot of these configurations are actually isomorphic to other configurations through rotations and/or reflections. For example, there are a total of 8 configurations where exactly one corner has value below the threshold, but these 8 configurations are equivalent to each other (these are also equivalent to the 8 configurations where there is exactly one corner with value above the threshold); with just this one case, we&#39;ve already reduced the number of configurations by 16 - 1 = 15. In total, the paper presents 15 unique configurations. Given these configurations, the paper hard-codes which edges pass through the surface (i.e. connect a vertex with value above the threshold with a vertex with value below the threshold)</span><span>. Finally, the paper </span><span class="c13">uses interpolation to compute the corners of the triangular mesh</span><span>, which we have done as well. </span></p><p class="c0 c1"><span class="c5"></span></p><p class="c0"><span class="c13">We utilized a union find approach because we felt that it was easier to implement as well as more technically challenging (especially when compared to hard-coding a bunch of values). There</span><span>&nbsp;are some immediate benefits to choosing this approach as opposed to hard-coding. For example, it would take a whole lot of computation to create mesh triangles with vertices not on either cube vertices or edge midpoints using the hard-coding approach, but it&rsquo;s a lot more natural using our method.</span><span class="c13">&nbsp;</span><span>However, o</span><span class="c5">ur approach does also have some downsides. For example, it does run slower than the hard-coded method, as ours needs to compute the connected components while the hard-coded method only needs to index into an array. </span></p><p class="c0 c1"><span class="c5"></span></p><h2 class="c0 c9" id="h.s6bae7lpes6m"><span class="c10">Renderer</span></h2><p class="c0"><span class="c13">Finally, to render the mesh, we utilized the shader</span><span>s </span><span class="c13">that we created in Project 4. The shaders we considered included mirror, normal, </span><span>P</span><span class="c13">hong, </span><span>and texture. </span><span class="c13">We thought that</span><span class="c5">&nbsp;the best shader in this case was the mirror shader, due to its reflective qualities that are very similar to water&#39;s reflective properties. </span></p><p class="c0 c1"><span class="c5"></span></p><h2 class="c0 c9" id="h.53sxofqfo9m4"><span class="c10">Problems Encountered</span></h2><p class="c0"><span>We encountered a variety of problems while implementing our project. To start, we had to figure out a way to convert all mentions of </span><span class="c2">Cloth</span><span>&nbsp;and </span><span class="c2">ClothParameters</span><span>&nbsp;into </span><span class="c2">Fluid</span><span>&nbsp;and </span><span class="c2">FluidParameters</span><span>&nbsp;instead. This was more difficult than expected because we had to comb through the entire codebase and try to understand a lot of the code that we did not need to deal with in project 4. This includes, for example, both how the </span><span class="c2">clothSimulator</span><span class="c5">&nbsp;is actually rendered in main.cpp, and how the screen in Project 4 works and screenshots were taken on canvases in Project 1. We also had problems writing the mesh. There were multiple very pesky bugs, including spatial cells on the sides being smaller than cells in the center due to non-integral division. </span></p><p class="c0 c1"><span class="c5"></span></p><h2 class="c0 c9" id="h.v3p8xbcg6v3o"><span class="c10">Lessons Learned</span></h2><p class="c0"><span>Throughout this project we learned a variety of lessons. For example, we learned how to understand and modify a large codebase that was written by others. We also learned how to understand formulas and ideas from research papers and adapt them efficiently in ways that best fit our needs.</span></p><p class="c0 c1"><span class="c5"></span></p><h1 class="c8 c9" id="h.vf8fpp9x9xzs"><span class="c6">Results</span></h1><p class="c0"><span class="c5">Although we did not have the compute power to simulate larger numbers of particles for a finer grained mesh, we were able to simulate many of the emergent properties that occur in fluid flow at a coarser level. As we can see with these images, our mesh is able to represent a complicated and realistic fluid surface.</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 312.00px; height: 224.64px;"><img alt="" src="images/image23.png" style="width: 312.00px; height: 224.64px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c5">As seen in the above image, we are able to render fluid droplets in the air. However, they are pretty big given that our resolution is pretty low. With more compute power, we would be able to increase the resolution, and the fluid droplets would appear smaller as well as smoother. </span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 312.00px; height: 239.52px;"><img alt="" src="images/image27.png" style="width: 312.00px; height: 239.52px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span class="c5"></span></p><p class="c0"><span class="c5">We have multiple scenarios. Our first scenario [FluidSimulationWithoutMeshFaster] shows our particles without any mesh elements. We can see how the particles bounce off walls and push away from each other. This is run with 5000 particles and water conditions. </span></p><p class="c0 c1"><span class="c5"></span></p><p class="c0"><span class="c5">Our second video [FluidSimulationMesh1] shows a scenario with relatively high viscosity and high friction on the walls. This causes the water to stick to the walls and itself more. This is run with 20000 particles. </span></p><p class="c0 c1"><span class="c5"></span></p><p class="c0"><span class="c5">Our last video [FluidSimulationMesh2] shows a scenario with relatively low viscosity and low wall friction. This causes the fluid to bounce up and down more, which additionally makes it take longer to converge. </span></p><p class="c0 c1"><span class="c5"></span></p><p class="c0"><span>Slides: </span><span class="c17"><a class="c11" href="https://www.google.com/url?q=https://docs.google.com/presentation/d/1c_EhwHQl0BHQLOtCM2nGpHYvjQQBXiOIBgnIEQ-saPk/edit%23slide%3Did.p&amp;sa=D&amp;source=editors&amp;ust=1683229468843922&amp;usg=AOvVaw3DyDUJfhyQN6SpvOPcxYVm">CS 184 Final Project Slides</a></span></p><p class="c0"><span>Github: </span><span class="c14"><a class="c11" href="https://www.google.com/url?q=https://github.com/JophiArcana/CS184-Final-Project&amp;sa=D&amp;source=editors&amp;ust=1683229468844513&amp;usg=AOvVaw00xdZcBVdZo3DT-7ue1Hno">https://github.com/JophiArcana/CS184-Final-Project</a></span></p><p class="c0"><span>Google Drive: </span><span class="c14"><a class="c11" href="https://www.google.com/url?q=https://drive.google.com/drive/u/1/folders/16jpouCX--Z6y6U2r8396WFv_yI8N411H&amp;sa=D&amp;source=editors&amp;ust=1683229468845047&amp;usg=AOvVaw1xty2WcAzQ1uCtQ8km75zb">https://drive.google.com/drive/u/1/folders/16jpouCX--Z6y6U2r8396WFv_yI8N411H</a></span></p><h1 class="c8 c9" id="h.reauh1dhmx22"><span class="c6">References</span></h1><ul class="c15 lst-kix_mqnvcge7nm4b-0 start"><li class="c0 c4 li-bullet-0"><span class="c14"><a class="c11" href="https://www.google.com/url?q=https://cg.informatik.uni-freiburg.de/publications/2014_EG_SPH_STAR.pdf&amp;sa=D&amp;source=editors&amp;ust=1683229468845802&amp;usg=AOvVaw0mE7Meauc0V0fww-t3RLr8">https://cg.informatik.uni-freiburg.de/publications/2014_EG_SPH_STAR.pdf</a></span></li><li class="c0 c4 li-bullet-0"><span class="c14"><a class="c11" href="https://www.google.com/url?q=http://mmacklin.com/pbf_sig_preprint.pdf&amp;sa=D&amp;source=editors&amp;ust=1683229468846263&amp;usg=AOvVaw2X8rhfhO979m52n1qIcr2_">http://mmacklin.com/pbf_sig_preprint.pdf</a></span></li><li class="c0 c4 li-bullet-0"><span class="c14"><a class="c11" href="https://www.google.com/url?q=https://cseweb.ucsd.edu/classes/sp19/cse291-d/Files/CSE291_09_ParticleBasedFluids.pdf&amp;sa=D&amp;source=editors&amp;ust=1683229468846654&amp;usg=AOvVaw1wsbNl7R6QlccNxAyJWAuB">https://cseweb.ucsd.edu/classes/sp19/cse291-d/Files/CSE291_09_ParticleBasedFluids.pdf</a></span></li><li class="c0 c4 li-bullet-0"><span class="c14"><a class="c11" href="https://www.google.com/url?q=https://graphics.stanford.edu/~mdfisher/MarchingCubes.html&amp;sa=D&amp;source=editors&amp;ust=1683229468847233&amp;usg=AOvVaw2gdwVuThLlgtEvMZ0vkk7-">https://graphics.stanford.edu/~mdfisher/MarchingCubes.html</a></span></li></ul><p class="c0 c1"><span class="c5"></span></p><h1 class="c8 c9" id="h.ijt7qtr8cp8h"><span class="c6">Contributions</span></h1><ul class="c15 lst-kix_2whi0pyhiphv-0 start"><li class="c0 c4 li-bullet-0"><span class="c5">Jonathan Guo - researched and helped implement the cube marching algorithm for mesh creation. Also helped refactor existing cloth code into fluid code. </span></li><li class="c0 c4 li-bullet-0"><span class="c5">Andrew Huang - researched and primarily worked with compatibility with existing project code (i.e. automatic screenshotting for our videos). Also helped out with cube marching and compiled results.</span></li><li class="c0 c4 li-bullet-0"><span>Wentinn Liao - researched and implemented methods of physics simulation and set up core structure for computation. Implemented spatial hashing, and batch/global computations for kernel, kernel gradient, incompressibility, vorticity, and viscosity. Also implemented multithreading that allowed for nearly 4x speedup of initial code.</span></li></ul></body></html>